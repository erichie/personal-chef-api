import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { requireAuth } from "@/lib/auth-utils";
import { handleApiError } from "@/lib/api-errors";
import {
  generateHybridReplacement,
  type ReplaceRecipeRequest,
} from "@/lib/ai-utils";
import { prisma } from "@/lib/prisma";
import { v4 as uuidv4 } from "uuid";
import { generateRecipeEmbedding } from "@/lib/embedding-utils";

const replaceRecipeRequestSchema = z.object({
  originalRecipe: z.object({
    title: z.string(),
    ingredients: z.array(z.any()).optional(),
    totalMinutes: z.number().optional(),
  }),
  replacementReason: z.string(),
  preferences: z.any().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const { user } = await requireAuth(request);

    const body = await request.json();
    const payload: ReplaceRecipeRequest =
      replaceRecipeRequestSchema.parse(body);

    // TODO: Check user credits/tokens before generating
    // TODO: Deduct credits after successful generation

    // Generate replacement recipe using hybrid approach (database + AI)
    const { recipe: replacementRecipeData, source } =
      await generateHybridReplacement(payload);

    let recipe;

    if (source === "database") {
      // Recipe found in database - use it directly
      recipe = replacementRecipeData;
    } else {
      // Recipe generated by AI - store it
      const recipeId = uuidv4();

      // Generate embedding for the new recipe
      let embedding: number[] | null = null;
      try {
        embedding = await generateRecipeEmbedding({
          title: replacementRecipeData.title,
          description: replacementRecipeData.description,
          tags: replacementRecipeData.tags,
          ingredients: replacementRecipeData.ingredients,
        });
      } catch (error) {
        console.error("Failed to generate embedding:", error);
        // Continue without embedding
      }

      // Create recipe without embedding first
      recipe = await prisma.recipe.create({
        data: {
          id: recipeId,
          userId: user.id,
          title: replacementRecipeData.title,
          description: replacementRecipeData.description || null,
          servings: replacementRecipeData.servings || null,
          totalMinutes: replacementRecipeData.totalMinutes || null,
          tags: replacementRecipeData.tags || null,
          ingredients: replacementRecipeData.ingredients || [],
          steps: replacementRecipeData.steps || null,
          source: "generated",
          embeddingVersion: embedding ? 1 : null,
        },
      });

      // Update with embedding using raw SQL if we have one
      if (embedding) {
        await prisma.$executeRawUnsafe(
          `UPDATE "Recipe" SET embedding = $1::vector WHERE id = $2`,
          `[${embedding.join(",")}]`,
          recipeId
        );
      }
    }

    return NextResponse.json({
      recipe: {
        id: recipe.id,
        title: recipe.title,
        description: recipe.description,
        servings: recipe.servings,
        totalMinutes: recipe.totalMinutes,
        tags: recipe.tags,
        ingredients: recipe.ingredients,
        steps: recipe.steps,
        source: recipe.source,
        createdAt: recipe.createdAt,
      },
      recipeSource: source, // "database" or "ai"
      message: `Replacement recipe ${
        source === "database" ? "found" : "generated"
      } successfully`,
    });
  } catch (error) {
    return handleApiError(error);
  }
}
