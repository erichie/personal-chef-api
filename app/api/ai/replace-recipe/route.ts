import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { requireAuth } from "@/lib/auth-utils";
import { handleApiError } from "@/lib/api-errors";
import {
  generateHybridReplacement,
  type ReplaceRecipeRequest,
} from "@/lib/ai-utils";
import { prisma } from "@/lib/prisma";
import { v4 as uuidv4 } from "uuid";
import { generateRecipeEmbedding } from "@/lib/embedding-utils";
import {
  trackAiUsage,
  AiEndpoint,
  checkReplaceRecipeLimit,
  validateUserTokens,
  MEAL_PLAN_TOKEN_COST,
} from "@/lib/ai-usage-utils";

const replaceRecipeRequestSchema = z.object({
  originalRecipe: z.object({
    title: z.string(),
    ingredients: z.array(z.any()).optional(),
    totalMinutes: z.number().optional(),
  }),
  replacementReason: z.string(),
  preferences: z.any().optional(),
  tokensToUse: z.number().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const { user } = await requireAuth(request);

    const body = await request.json();
    const payload: ReplaceRecipeRequest =
      replaceRecipeRequestSchema.parse(body);

    let usedTokens = false;

    // If tokens are provided, validate them instead of checking limit
    if (payload.tokensToUse !== undefined) {
      if (payload.tokensToUse !== MEAL_PLAN_TOKEN_COST) {
        return NextResponse.json(
          {
            error: "Invalid token amount",
            code: "INVALID_TOKEN_AMOUNT",
            details: {
              required: MEAL_PLAN_TOKEN_COST,
              provided: payload.tokensToUse,
            },
          },
          { status: 400 }
        );
      }

      const tokenValidation = await validateUserTokens(
        user.id,
        MEAL_PLAN_TOKEN_COST
      );

      if (!tokenValidation.valid) {
        return NextResponse.json(
          {
            error: tokenValidation.error || "Insufficient tokens",
            code: "INSUFFICIENT_TOKENS",
            details: {
              required: MEAL_PLAN_TOKEN_COST,
              currentBalance: tokenValidation.currentBalance,
            },
          },
          { status: 402 }
        );
      }

      usedTokens = true;
    } else {
      // No tokens provided - check normal limit
      const limitCheck = await checkReplaceRecipeLimit(user.id);
      if (!limitCheck.allowed) {
        return NextResponse.json(
          {
            error: "Recipe replacement limit reached",
            code: "LIMIT_EXCEEDED",
            details: {
              limit: limitCheck.limit,
              used: limitCheck.used,
              remaining: limitCheck.remaining,
              resetsAt: limitCheck.resetsAt,
              isLifetime: limitCheck.resetsAt === null,
              tokenCost: MEAL_PLAN_TOKEN_COST,
            },
          },
          { status: 429 }
        );
      }
    }

    // Generate replacement recipe using hybrid approach (database + AI)
    const { recipe: replacementRecipeData, source } =
      await generateHybridReplacement(payload);

    let recipe;

    if (source === "database") {
      // Recipe found in database - use it directly
      recipe = replacementRecipeData;
    } else {
      // Recipe generated by AI - store it
      const recipeId = uuidv4();

      // Generate embedding for the new recipe
      let embedding: number[] | null = null;
      try {
        embedding = await generateRecipeEmbedding({
          title: replacementRecipeData.title,
          description: replacementRecipeData.description,
          tags: replacementRecipeData.tags,
          ingredients: replacementRecipeData.ingredients,
        });
      } catch (error) {
        console.error("Failed to generate embedding:", error);
        // Continue without embedding
      }

      // Create recipe without embedding first
      recipe = await prisma.recipe.create({
        data: {
          id: recipeId,
          userId: user.id,
          title: replacementRecipeData.title,
          description: replacementRecipeData.description || null,
          servings: replacementRecipeData.servings || null,
          totalMinutes: replacementRecipeData.totalMinutes || null,
          tags: replacementRecipeData.tags || null,
          ingredients: replacementRecipeData.ingredients || [],
          steps: replacementRecipeData.steps || null,
          source: "generated",
          embeddingVersion: embedding ? 1 : null,
        },
      });

      // Update with embedding using raw SQL if we have one
      if (embedding) {
        await prisma.$executeRawUnsafe(
          `UPDATE "Recipe" SET embedding = $1::vector WHERE id = $2`,
          `[${embedding.join(",")}]`,
          recipeId
        );
      }
    }

    // Track usage
    await trackAiUsage(user.id, AiEndpoint.REPLACE_RECIPE);

    // Map database source to mobile app expected values
    // Database stores "generated" but mobile expects "ai", "url", or "manual"
    const mappedSource =
      recipe.source === "generated" ? "ai" : recipe.source || "ai";

    // Return recipe fields at root level for mobile app compatibility
    return NextResponse.json({
      id: recipe.id,
      title: recipe.title,
      description: recipe.description,
      servings: recipe.servings,
      totalMinutes: recipe.totalMinutes,
      tags: recipe.tags,
      ingredients: recipe.ingredients,
      steps: recipe.steps,
      source: mappedSource,
      createdAt: recipe.createdAt,
      // Metadata
      recipeSource: source, // "database" or "ai"
      usedTokens,
      tokensUsed: usedTokens ? MEAL_PLAN_TOKEN_COST : 0,
      message: `Replacement recipe ${
        source === "database" ? "found" : "generated"
      } successfully${usedTokens ? " using tokens" : ""}`,
    });
  } catch (error) {
    return handleApiError(error);
  }
}
